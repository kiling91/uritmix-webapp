/* tslint:disable */
/* eslint-disable */
/**
 * Uritmix.Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Abonnement
 */
export interface Abonnement {
    /**
     * 
     * @type {number}
     * @memberof Abonnement
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Abonnement
     */
    'name'?: string;
    /**
     * 
     * @type {AbonnementValidityView}
     * @memberof Abonnement
     */
    'validity'?: AbonnementValidityView;
    /**
     * 
     * @type {number}
     * @memberof Abonnement
     */
    'maxNumberOfVisits'?: number;
    /**
     * 
     * @type {number}
     * @memberof Abonnement
     */
    'basePrice'?: number;
    /**
     * 
     * @type {DiscountView}
     * @memberof Abonnement
     */
    'maxDiscount'?: DiscountView;
    /**
     * 
     * @type {Array<Lesson>}
     * @memberof Abonnement
     */
    'lessons'?: Array<Lesson>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AbonnementValidityView = {
    OneDay: 'OneDay',
    OneMonth: 'OneMonth',
    ThreeMonths: 'ThreeMonths',
    HalfYear: 'HalfYear',
    Year: 'Year'
} as const;

export type AbonnementValidityView = typeof AbonnementValidityView[keyof typeof AbonnementValidityView];


/**
 * 
 * @export
 * @interface ActivateAuth
 */
export interface ActivateAuth {
    /**
     * 
     * @type {string}
     * @memberof ActivateAuth
     */
    'confirmCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivateAuth
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivateAuth
     */
    'passwordConfirm'?: string;
}
/**
 * 
 * @export
 * @interface Auth
 */
export interface Auth {
    /**
     * 
     * @type {AuthRoleView}
     * @memberof Auth
     */
    'role'?: AuthRoleView;
    /**
     * 
     * @type {AuthStatusView}
     * @memberof Auth
     */
    'status'?: AuthStatusView;
    /**
     * 
     * @type {string}
     * @memberof Auth
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AuthRoleView = {
    Manager: 'Manager',
    Admin: 'Admin',
    Server: 'Server'
} as const;

export type AuthRoleView = typeof AuthRoleView[keyof typeof AuthRoleView];


/**
 * 
 * @export
 * @enum {string}
 */

export const AuthStatusView = {
    NotActivated: 'NotActivated',
    Activated: 'Activated',
    Blocked: 'Blocked'
} as const;

export type AuthStatusView = typeof AuthStatusView[keyof typeof AuthStatusView];


/**
 * 
 * @export
 * @interface CreateAbonnement
 */
export interface CreateAbonnement {
    /**
     * 
     * @type {string}
     * @memberof CreateAbonnement
     */
    'name'?: string;
    /**
     * 
     * @type {AbonnementValidityView}
     * @memberof CreateAbonnement
     */
    'validity'?: AbonnementValidityView;
    /**
     * 
     * @type {number}
     * @memberof CreateAbonnement
     */
    'maxNumberOfVisits'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAbonnement
     */
    'basePrice'?: number;
    /**
     * 
     * @type {DiscountView}
     * @memberof CreateAbonnement
     */
    'maxDiscount'?: DiscountView;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateAbonnement
     */
    'lessonIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateAuth
 */
export interface CreateAuth {
    /**
     * 
     * @type {string}
     * @memberof CreateAuth
     */
    'email'?: string;
    /**
     * 
     * @type {AuthRoleView}
     * @memberof CreateAuth
     */
    'role'?: AuthRoleView;
}
/**
 * 
 * @export
 * @interface CreateLesson
 */
export interface CreateLesson {
    /**
     * 
     * @type {string}
     * @memberof CreateLesson
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateLesson
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateLesson
     */
    'trainerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateLesson
     */
    'durationMinute'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateLesson
     */
    'basePrice'?: number;
}
/**
 * 
 * @export
 * @interface CreatePerson
 */
export interface CreatePerson {
    /**
     * 
     * @type {string}
     * @memberof CreatePerson
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePerson
     */
    'lastName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePerson
     */
    'isTrainer'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreatePerson
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateRoom
 */
export interface CreateRoom {
    /**
     * 
     * @type {string}
     * @memberof CreateRoom
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoom
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DiscountView = {
    D0: 'D0',
    D5: 'D5',
    D10: 'D10',
    D15: 'D15',
    D20: 'D20',
    D25: 'D25',
    D30: 'D30',
    D40: 'D40',
    D50: 'D50',
    D60: 'D60',
    D70: 'D70',
    D80: 'D80',
    D90: 'D90'
} as const;

export type DiscountView = typeof DiscountView[keyof typeof DiscountView];


/**
 * 
 * @export
 * @interface EditAbonnement
 */
export interface EditAbonnement {
    /**
     * 
     * @type {string}
     * @memberof EditAbonnement
     */
    'name'?: string;
    /**
     * 
     * @type {AbonnementValidityView}
     * @memberof EditAbonnement
     */
    'validity'?: AbonnementValidityView;
    /**
     * 
     * @type {number}
     * @memberof EditAbonnement
     */
    'maxNumberOfVisits'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditAbonnement
     */
    'basePrice'?: number;
    /**
     * 
     * @type {DiscountView}
     * @memberof EditAbonnement
     */
    'maxDiscount'?: DiscountView;
    /**
     * 
     * @type {Array<number>}
     * @memberof EditAbonnement
     */
    'lessonIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EditLesson
 */
export interface EditLesson {
    /**
     * 
     * @type {string}
     * @memberof EditLesson
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditLesson
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EditLesson
     */
    'trainerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditLesson
     */
    'durationMinute'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditLesson
     */
    'basePrice'?: number;
}
/**
 * 
 * @export
 * @interface EditPerson
 */
export interface EditPerson {
    /**
     * 
     * @type {string}
     * @memberof EditPerson
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditPerson
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditPerson
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface EditRoom
 */
export interface EditRoom {
    /**
     * 
     * @type {string}
     * @memberof EditRoom
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditRoom
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Lesson
 */
export interface Lesson {
    /**
     * 
     * @type {number}
     * @memberof Lesson
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Lesson
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lesson
     */
    'description'?: string | null;
    /**
     * 
     * @type {Person}
     * @memberof Lesson
     */
    'trainer'?: Person;
    /**
     * 
     * @type {number}
     * @memberof Lesson
     */
    'durationMinute'?: number;
    /**
     * 
     * @type {number}
     * @memberof Lesson
     */
    'basePrice'?: number;
}
/**
 * 
 * @export
 * @interface LoggedPerson
 */
export interface LoggedPerson {
    /**
     * 
     * @type {string}
     * @memberof LoggedPerson
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedPerson
     */
    'lastName'?: string;
    /**
     * 
     * @type {AuthRoleView}
     * @memberof LoggedPerson
     */
    'role'?: AuthRoleView;
    /**
     * 
     * @type {string}
     * @memberof LoggedPerson
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedPerson
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedPerson
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface LoginUser
 */
export interface LoginUser {
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface Logout
 */
export interface Logout {
    /**
     * 
     * @type {string}
     * @memberof Logout
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedAbonnement
 */
export interface PaginatedAbonnement {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAbonnement
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedAbonnement
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedAbonnement
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedAbonnement
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaginatedAbonnement
     */
    'nextPageExists'?: boolean;
    /**
     * 
     * @type {Array<Abonnement>}
     * @memberof PaginatedAbonnement
     */
    'results'?: Array<Abonnement> | null;
}
/**
 * 
 * @export
 * @interface PaginatedLesson
 */
export interface PaginatedLesson {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLesson
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedLesson
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedLesson
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedLesson
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaginatedLesson
     */
    'nextPageExists'?: boolean;
    /**
     * 
     * @type {Array<Lesson>}
     * @memberof PaginatedLesson
     */
    'results'?: Array<Lesson> | null;
}
/**
 * 
 * @export
 * @interface PaginatedPerson
 */
export interface PaginatedPerson {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPerson
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedPerson
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedPerson
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedPerson
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaginatedPerson
     */
    'nextPageExists'?: boolean;
    /**
     * 
     * @type {Array<Person>}
     * @memberof PaginatedPerson
     */
    'results'?: Array<Person> | null;
}
/**
 * 
 * @export
 * @interface PaginatedRoom
 */
export interface PaginatedRoom {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRoom
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedRoom
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedRoom
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedRoom
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaginatedRoom
     */
    'nextPageExists'?: boolean;
    /**
     * 
     * @type {Array<Room>}
     * @memberof PaginatedRoom
     */
    'results'?: Array<Room> | null;
}
/**
 * 
 * @export
 * @interface PaginatedSoldAbonnement
 */
export interface PaginatedSoldAbonnement {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSoldAbonnement
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedSoldAbonnement
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedSoldAbonnement
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedSoldAbonnement
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaginatedSoldAbonnement
     */
    'nextPageExists'?: boolean;
    /**
     * 
     * @type {Array<SoldAbonnement>}
     * @memberof PaginatedSoldAbonnement
     */
    'results'?: Array<SoldAbonnement> | null;
}
/**
 * 
 * @export
 * @interface PasswordReset
 */
export interface PasswordReset {
    /**
     * 
     * @type {string}
     * @memberof PasswordReset
     */
    'confirmCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordReset
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordReset
     */
    'passwordConfirm'?: string;
}
/**
 * 
 * @export
 * @interface PasswordResetQuery
 */
export interface PasswordResetQuery {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetQuery
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {number}
     * @memberof Person
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'isTrainer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'haveAuth'?: boolean;
    /**
     * 
     * @type {Auth}
     * @memberof Person
     */
    'auth'?: Auth;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PersonTypeView = {
    All: 'All',
    Trainer: 'Trainer',
    Account: 'Account'
} as const;

export type PersonTypeView = typeof PersonTypeView[keyof typeof PersonTypeView];


/**
 * 
 * @export
 * @interface PropertyError
 */
export interface PropertyError {
    /**
     * 
     * @type {string}
     * @memberof PropertyError
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyError
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface Refresh
 */
export interface Refresh {
    /**
     * 
     * @type {string}
     * @memberof Refresh
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ResultAbonnement
 */
export interface ResultAbonnement {
    /**
     * 
     * @type {Abonnement}
     * @memberof ResultAbonnement
     */
    'result'?: Abonnement;
    /**
     * 
     * @type {string}
     * @memberof ResultAbonnement
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultAbonnement
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultLesson
 */
export interface ResultLesson {
    /**
     * 
     * @type {Lesson}
     * @memberof ResultLesson
     */
    'result'?: Lesson;
    /**
     * 
     * @type {string}
     * @memberof ResultLesson
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultLesson
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultLoggedPerson
 */
export interface ResultLoggedPerson {
    /**
     * 
     * @type {LoggedPerson}
     * @memberof ResultLoggedPerson
     */
    'result'?: LoggedPerson;
    /**
     * 
     * @type {string}
     * @memberof ResultLoggedPerson
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultLoggedPerson
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultPaginatedAbonnement
 */
export interface ResultPaginatedAbonnement {
    /**
     * 
     * @type {PaginatedAbonnement}
     * @memberof ResultPaginatedAbonnement
     */
    'result'?: PaginatedAbonnement;
    /**
     * 
     * @type {string}
     * @memberof ResultPaginatedAbonnement
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultPaginatedAbonnement
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultPaginatedLesson
 */
export interface ResultPaginatedLesson {
    /**
     * 
     * @type {PaginatedLesson}
     * @memberof ResultPaginatedLesson
     */
    'result'?: PaginatedLesson;
    /**
     * 
     * @type {string}
     * @memberof ResultPaginatedLesson
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultPaginatedLesson
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultPaginatedPerson
 */
export interface ResultPaginatedPerson {
    /**
     * 
     * @type {PaginatedPerson}
     * @memberof ResultPaginatedPerson
     */
    'result'?: PaginatedPerson;
    /**
     * 
     * @type {string}
     * @memberof ResultPaginatedPerson
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultPaginatedPerson
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultPaginatedRoom
 */
export interface ResultPaginatedRoom {
    /**
     * 
     * @type {PaginatedRoom}
     * @memberof ResultPaginatedRoom
     */
    'result'?: PaginatedRoom;
    /**
     * 
     * @type {string}
     * @memberof ResultPaginatedRoom
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultPaginatedRoom
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultPaginatedSoldAbonnement
 */
export interface ResultPaginatedSoldAbonnement {
    /**
     * 
     * @type {PaginatedSoldAbonnement}
     * @memberof ResultPaginatedSoldAbonnement
     */
    'result'?: PaginatedSoldAbonnement;
    /**
     * 
     * @type {string}
     * @memberof ResultPaginatedSoldAbonnement
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultPaginatedSoldAbonnement
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultPerson
 */
export interface ResultPerson {
    /**
     * 
     * @type {Person}
     * @memberof ResultPerson
     */
    'result'?: Person;
    /**
     * 
     * @type {string}
     * @memberof ResultPerson
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultPerson
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultRoom
 */
export interface ResultRoom {
    /**
     * 
     * @type {Room}
     * @memberof ResultRoom
     */
    'result'?: Room;
    /**
     * 
     * @type {string}
     * @memberof ResultRoom
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRoom
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultSoldAbonnement
 */
export interface ResultSoldAbonnement {
    /**
     * 
     * @type {SoldAbonnement}
     * @memberof ResultSoldAbonnement
     */
    'result'?: SoldAbonnement;
    /**
     * 
     * @type {string}
     * @memberof ResultSoldAbonnement
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultSoldAbonnement
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultUnit
 */
export interface ResultUnit {
    /**
     * 
     * @type {object}
     * @memberof ResultUnit
     */
    'result'?: object;
    /**
     * 
     * @type {string}
     * @memberof ResultUnit
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ResultUnit
     */
    'ok'?: boolean;
}
/**
 * 
 * @export
 * @interface Room
 */
export interface Room {
    /**
     * 
     * @type {number}
     * @memberof Room
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface SaleAbonnement
 */
export interface SaleAbonnement {
    /**
     * 
     * @type {number}
     * @memberof SaleAbonnement
     */
    'personId'?: number;
    /**
     * 
     * @type {number}
     * @memberof SaleAbonnement
     */
    'abonnementId'?: number;
    /**
     * 
     * @type {DiscountView}
     * @memberof SaleAbonnement
     */
    'discount'?: DiscountView;
}
/**
 * 
 * @export
 * @interface SoldAbonnement
 */
export interface SoldAbonnement {
    /**
     * 
     * @type {number}
     * @memberof SoldAbonnement
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SoldAbonnement
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SoldAbonnement
     */
    'dateSale'?: string;
    /**
     * 
     * @type {string}
     * @memberof SoldAbonnement
     */
    'dateExpiration'?: string;
    /**
     * 
     * @type {number}
     * @memberof SoldAbonnement
     */
    'priceSold'?: number;
    /**
     * 
     * @type {DiscountView}
     * @memberof SoldAbonnement
     */
    'discount'?: DiscountView;
    /**
     * 
     * @type {number}
     * @memberof SoldAbonnement
     */
    'visitCounter'?: number;
    /**
     * 
     * @type {string}
     * @memberof SoldAbonnement
     */
    'name'?: string;
    /**
     * 
     * @type {AbonnementValidityView}
     * @memberof SoldAbonnement
     */
    'validity'?: AbonnementValidityView;
    /**
     * 
     * @type {number}
     * @memberof SoldAbonnement
     */
    'maxNumberOfVisits'?: number;
    /**
     * 
     * @type {number}
     * @memberof SoldAbonnement
     */
    'basePrice'?: number;
    /**
     * 
     * @type {Array<Lesson>}
     * @memberof SoldAbonnement
     */
    'lessons'?: Array<Lesson>;
}
/**
 * 
 * @export
 * @interface ValidError
 */
export interface ValidError {
    /**
     * 
     * @type {Array<PropertyError>}
     * @memberof ValidError
     */
    'properties'?: Array<PropertyError>;
}

/**
 * AbonnementApi - axios parameter creator
 * @export
 */
export const AbonnementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Возвращает абоннемент по id
         * @param {number} abonnementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementAbonnementIdGet: async (abonnementId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'abonnementId' is not null or undefined
            assertParamExists('apiV1AbonnementAbonnementIdGet', 'abonnementId', abonnementId)
            const localVarPath = `/api/v1/abonnement/{abonnementId}`
                .replace(`{${"abonnementId"}}`, encodeURIComponent(String(abonnementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновляет данные абонимента
         * @param {number} abonnementId 
         * @param {EditAbonnement} [editAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementAbonnementIdPut: async (abonnementId: number, editAbonnement?: EditAbonnement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'abonnementId' is not null or undefined
            assertParamExists('apiV1AbonnementAbonnementIdPut', 'abonnementId', abonnementId)
            const localVarPath = `/api/v1/abonnement/{abonnementId}`
                .replace(`{${"abonnementId"}}`, encodeURIComponent(String(abonnementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editAbonnement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Возвращает список абониментов
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementGet: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('apiV1AbonnementGet', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('apiV1AbonnementGet', 'pageNumber', pageNumber)
            const localVarPath = `/api/v1/abonnement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создает новый абонимент
         * @param {CreateAbonnement} [createAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementPost: async (createAbonnement?: CreateAbonnement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/abonnement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAbonnement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Возвращает список купленных абониментов пользователя
         * @param {number} personId 
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementSoldPersonIdGet: async (personId: number, pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('apiV1AbonnementSoldPersonIdGet', 'personId', personId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('apiV1AbonnementSoldPersonIdGet', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('apiV1AbonnementSoldPersonIdGet', 'pageNumber', pageNumber)
            const localVarPath = `/api/v1/abonnement/sold/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Продажа абонимента
         * @param {SaleAbonnement} [saleAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementSoldPost: async (saleAbonnement?: SaleAbonnement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/abonnement/sold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saleAbonnement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AbonnementApi - functional programming interface
 * @export
 */
export const AbonnementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AbonnementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Возвращает абоннемент по id
         * @param {number} abonnementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AbonnementAbonnementIdGet(abonnementId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultAbonnement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AbonnementAbonnementIdGet(abonnementId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Обновляет данные абонимента
         * @param {number} abonnementId 
         * @param {EditAbonnement} [editAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AbonnementAbonnementIdPut(abonnementId: number, editAbonnement?: EditAbonnement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultAbonnement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AbonnementAbonnementIdPut(abonnementId, editAbonnement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Возвращает список абониментов
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AbonnementGet(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPaginatedAbonnement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AbonnementGet(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Создает новый абонимент
         * @param {CreateAbonnement} [createAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AbonnementPost(createAbonnement?: CreateAbonnement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultAbonnement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AbonnementPost(createAbonnement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Возвращает список купленных абониментов пользователя
         * @param {number} personId 
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AbonnementSoldPersonIdGet(personId: number, pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPaginatedSoldAbonnement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AbonnementSoldPersonIdGet(personId, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Продажа абонимента
         * @param {SaleAbonnement} [saleAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AbonnementSoldPost(saleAbonnement?: SaleAbonnement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultSoldAbonnement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AbonnementSoldPost(saleAbonnement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AbonnementApi - factory interface
 * @export
 */
export const AbonnementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AbonnementApiFp(configuration)
    return {
        /**
         * 
         * @summary Возвращает абоннемент по id
         * @param {number} abonnementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementAbonnementIdGet(abonnementId: number, options?: any): AxiosPromise<ResultAbonnement> {
            return localVarFp.apiV1AbonnementAbonnementIdGet(abonnementId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновляет данные абонимента
         * @param {number} abonnementId 
         * @param {EditAbonnement} [editAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementAbonnementIdPut(abonnementId: number, editAbonnement?: EditAbonnement, options?: any): AxiosPromise<ResultAbonnement> {
            return localVarFp.apiV1AbonnementAbonnementIdPut(abonnementId, editAbonnement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Возвращает список абониментов
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementGet(pageSize: number, pageNumber: number, options?: any): AxiosPromise<ResultPaginatedAbonnement> {
            return localVarFp.apiV1AbonnementGet(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создает новый абонимент
         * @param {CreateAbonnement} [createAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementPost(createAbonnement?: CreateAbonnement, options?: any): AxiosPromise<ResultAbonnement> {
            return localVarFp.apiV1AbonnementPost(createAbonnement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Возвращает список купленных абониментов пользователя
         * @param {number} personId 
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementSoldPersonIdGet(personId: number, pageSize: number, pageNumber: number, options?: any): AxiosPromise<ResultPaginatedSoldAbonnement> {
            return localVarFp.apiV1AbonnementSoldPersonIdGet(personId, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Продажа абонимента
         * @param {SaleAbonnement} [saleAbonnement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AbonnementSoldPost(saleAbonnement?: SaleAbonnement, options?: any): AxiosPromise<ResultSoldAbonnement> {
            return localVarFp.apiV1AbonnementSoldPost(saleAbonnement, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AbonnementApi - object-oriented interface
 * @export
 * @class AbonnementApi
 * @extends {BaseAPI}
 */
export class AbonnementApi extends BaseAPI {
    /**
     * 
     * @summary Возвращает абоннемент по id
     * @param {number} abonnementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbonnementApi
     */
    public apiV1AbonnementAbonnementIdGet(abonnementId: number, options?: AxiosRequestConfig) {
        return AbonnementApiFp(this.configuration).apiV1AbonnementAbonnementIdGet(abonnementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновляет данные абонимента
     * @param {number} abonnementId 
     * @param {EditAbonnement} [editAbonnement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbonnementApi
     */
    public apiV1AbonnementAbonnementIdPut(abonnementId: number, editAbonnement?: EditAbonnement, options?: AxiosRequestConfig) {
        return AbonnementApiFp(this.configuration).apiV1AbonnementAbonnementIdPut(abonnementId, editAbonnement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Возвращает список абониментов
     * @param {number} pageSize 
     * @param {number} pageNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbonnementApi
     */
    public apiV1AbonnementGet(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return AbonnementApiFp(this.configuration).apiV1AbonnementGet(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создает новый абонимент
     * @param {CreateAbonnement} [createAbonnement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbonnementApi
     */
    public apiV1AbonnementPost(createAbonnement?: CreateAbonnement, options?: AxiosRequestConfig) {
        return AbonnementApiFp(this.configuration).apiV1AbonnementPost(createAbonnement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Возвращает список купленных абониментов пользователя
     * @param {number} personId 
     * @param {number} pageSize 
     * @param {number} pageNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbonnementApi
     */
    public apiV1AbonnementSoldPersonIdGet(personId: number, pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return AbonnementApiFp(this.configuration).apiV1AbonnementSoldPersonIdGet(personId, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Продажа абонимента
     * @param {SaleAbonnement} [saleAbonnement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbonnementApi
     */
    public apiV1AbonnementSoldPost(saleAbonnement?: SaleAbonnement, options?: AxiosRequestConfig) {
        return AbonnementApiFp(this.configuration).apiV1AbonnementSoldPost(saleAbonnement, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Активация созданного пользователя
         * @param {ActivateAuth} [activateAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthActivatePost: async (activateAuth?: ActivateAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Авторизация пользователя
         * @param {LoginUser} [loginUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLoginPost: async (loginUser?: LoginUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Разлогин пользователя
         * @param {Logout} [logout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLogoutPost: async (logout?: Logout, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logout, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Смена пароля на основе токена отправленного на почту
         * @param {PasswordReset} [passwordReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthPasswordResetPost: async (passwordReset?: PasswordReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/password-reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Запрос на смену пароля
         * @param {PasswordResetQuery} [passwordResetQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthPasswordResetQueryPost: async (passwordResetQuery?: PasswordResetQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/password-reset-query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание аккаунта для пользователя
         * @param {number} personId 
         * @param {CreateAuth} [createAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthPersonIdPost: async (personId: number, createAuth?: CreateAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('apiV1AuthPersonIdPost', 'personId', personId)
            const localVarPath = `/api/v1/auth/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение нового token с помощью refresh token
         * @param {Refresh} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthRefreshPost: async (refresh?: Refresh, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Активация созданного пользователя
         * @param {ActivateAuth} [activateAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthActivatePost(activateAuth?: ActivateAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthActivatePost(activateAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Авторизация пользователя
         * @param {LoginUser} [loginUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthLoginPost(loginUser?: LoginUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultLoggedPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthLoginPost(loginUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Разлогин пользователя
         * @param {Logout} [logout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthLogoutPost(logout?: Logout, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthLogoutPost(logout, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Смена пароля на основе токена отправленного на почту
         * @param {PasswordReset} [passwordReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthPasswordResetPost(passwordReset?: PasswordReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthPasswordResetPost(passwordReset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Запрос на смену пароля
         * @param {PasswordResetQuery} [passwordResetQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthPasswordResetQueryPost(passwordResetQuery?: PasswordResetQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthPasswordResetQueryPost(passwordResetQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Создание аккаунта для пользователя
         * @param {number} personId 
         * @param {CreateAuth} [createAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthPersonIdPost(personId: number, createAuth?: CreateAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthPersonIdPost(personId, createAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Получение нового token с помощью refresh token
         * @param {Refresh} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthRefreshPost(refresh?: Refresh, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultLoggedPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthRefreshPost(refresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Активация созданного пользователя
         * @param {ActivateAuth} [activateAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthActivatePost(activateAuth?: ActivateAuth, options?: any): AxiosPromise<ResultUnit> {
            return localVarFp.apiV1AuthActivatePost(activateAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Авторизация пользователя
         * @param {LoginUser} [loginUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLoginPost(loginUser?: LoginUser, options?: any): AxiosPromise<ResultLoggedPerson> {
            return localVarFp.apiV1AuthLoginPost(loginUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Разлогин пользователя
         * @param {Logout} [logout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLogoutPost(logout?: Logout, options?: any): AxiosPromise<ResultUnit> {
            return localVarFp.apiV1AuthLogoutPost(logout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Смена пароля на основе токена отправленного на почту
         * @param {PasswordReset} [passwordReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthPasswordResetPost(passwordReset?: PasswordReset, options?: any): AxiosPromise<ResultUnit> {
            return localVarFp.apiV1AuthPasswordResetPost(passwordReset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Запрос на смену пароля
         * @param {PasswordResetQuery} [passwordResetQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthPasswordResetQueryPost(passwordResetQuery?: PasswordResetQuery, options?: any): AxiosPromise<ResultUnit> {
            return localVarFp.apiV1AuthPasswordResetQueryPost(passwordResetQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создание аккаунта для пользователя
         * @param {number} personId 
         * @param {CreateAuth} [createAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthPersonIdPost(personId: number, createAuth?: CreateAuth, options?: any): AxiosPromise<ResultUnit> {
            return localVarFp.apiV1AuthPersonIdPost(personId, createAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получение нового token с помощью refresh token
         * @param {Refresh} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthRefreshPost(refresh?: Refresh, options?: any): AxiosPromise<ResultLoggedPerson> {
            return localVarFp.apiV1AuthRefreshPost(refresh, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Активация созданного пользователя
     * @param {ActivateAuth} [activateAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthActivatePost(activateAuth?: ActivateAuth, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiV1AuthActivatePost(activateAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Авторизация пользователя
     * @param {LoginUser} [loginUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthLoginPost(loginUser?: LoginUser, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiV1AuthLoginPost(loginUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Разлогин пользователя
     * @param {Logout} [logout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthLogoutPost(logout?: Logout, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiV1AuthLogoutPost(logout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Смена пароля на основе токена отправленного на почту
     * @param {PasswordReset} [passwordReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthPasswordResetPost(passwordReset?: PasswordReset, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiV1AuthPasswordResetPost(passwordReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Запрос на смену пароля
     * @param {PasswordResetQuery} [passwordResetQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthPasswordResetQueryPost(passwordResetQuery?: PasswordResetQuery, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiV1AuthPasswordResetQueryPost(passwordResetQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создание аккаунта для пользователя
     * @param {number} personId 
     * @param {CreateAuth} [createAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthPersonIdPost(personId: number, createAuth?: CreateAuth, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiV1AuthPersonIdPost(personId, createAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получение нового token с помощью refresh token
     * @param {Refresh} [refresh] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthRefreshPost(refresh?: Refresh, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiV1AuthRefreshPost(refresh, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LessonApi - axios parameter creator
 * @export
 */
export const LessonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Возвращает список занятий
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LessonGet: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('apiV1LessonGet', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('apiV1LessonGet', 'pageNumber', pageNumber)
            const localVarPath = `/api/v1/lesson`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Возвращает занятие по id
         * @param {number} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LessonLessonIdGet: async (lessonId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('apiV1LessonLessonIdGet', 'lessonId', lessonId)
            const localVarPath = `/api/v1/lesson/{lessonId}`
                .replace(`{${"lessonId"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновляет данные занятия
         * @param {number} lessonId 
         * @param {EditLesson} [editLesson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LessonLessonIdPut: async (lessonId: number, editLesson?: EditLesson, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('apiV1LessonLessonIdPut', 'lessonId', lessonId)
            const localVarPath = `/api/v1/lesson/{lessonId}`
                .replace(`{${"lessonId"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editLesson, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создает новое занятие
         * @param {CreateLesson} [createLesson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LessonPost: async (createLesson?: CreateLesson, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/lesson`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLesson, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LessonApi - functional programming interface
 * @export
 */
export const LessonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LessonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Возвращает список занятий
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LessonGet(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPaginatedLesson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1LessonGet(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Возвращает занятие по id
         * @param {number} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LessonLessonIdGet(lessonId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultLesson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1LessonLessonIdGet(lessonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Обновляет данные занятия
         * @param {number} lessonId 
         * @param {EditLesson} [editLesson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LessonLessonIdPut(lessonId: number, editLesson?: EditLesson, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultLesson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1LessonLessonIdPut(lessonId, editLesson, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Создает новое занятие
         * @param {CreateLesson} [createLesson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LessonPost(createLesson?: CreateLesson, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultLesson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1LessonPost(createLesson, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LessonApi - factory interface
 * @export
 */
export const LessonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LessonApiFp(configuration)
    return {
        /**
         * 
         * @summary Возвращает список занятий
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LessonGet(pageSize: number, pageNumber: number, options?: any): AxiosPromise<ResultPaginatedLesson> {
            return localVarFp.apiV1LessonGet(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Возвращает занятие по id
         * @param {number} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LessonLessonIdGet(lessonId: number, options?: any): AxiosPromise<ResultLesson> {
            return localVarFp.apiV1LessonLessonIdGet(lessonId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновляет данные занятия
         * @param {number} lessonId 
         * @param {EditLesson} [editLesson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LessonLessonIdPut(lessonId: number, editLesson?: EditLesson, options?: any): AxiosPromise<ResultLesson> {
            return localVarFp.apiV1LessonLessonIdPut(lessonId, editLesson, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создает новое занятие
         * @param {CreateLesson} [createLesson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LessonPost(createLesson?: CreateLesson, options?: any): AxiosPromise<ResultLesson> {
            return localVarFp.apiV1LessonPost(createLesson, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LessonApi - object-oriented interface
 * @export
 * @class LessonApi
 * @extends {BaseAPI}
 */
export class LessonApi extends BaseAPI {
    /**
     * 
     * @summary Возвращает список занятий
     * @param {number} pageSize 
     * @param {number} pageNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public apiV1LessonGet(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return LessonApiFp(this.configuration).apiV1LessonGet(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Возвращает занятие по id
     * @param {number} lessonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public apiV1LessonLessonIdGet(lessonId: number, options?: AxiosRequestConfig) {
        return LessonApiFp(this.configuration).apiV1LessonLessonIdGet(lessonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновляет данные занятия
     * @param {number} lessonId 
     * @param {EditLesson} [editLesson] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public apiV1LessonLessonIdPut(lessonId: number, editLesson?: EditLesson, options?: AxiosRequestConfig) {
        return LessonApiFp(this.configuration).apiV1LessonLessonIdPut(lessonId, editLesson, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создает новое занятие
     * @param {CreateLesson} [createLesson] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public apiV1LessonPost(createLesson?: CreateLesson, options?: AxiosRequestConfig) {
        return LessonApiFp(this.configuration).apiV1LessonPost(createLesson, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonApi - axios parameter creator
 * @export
 */
export const PersonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Возвращает список пользователей
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {PersonTypeView} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonGet: async (pageSize: number, pageNumber: number, type?: PersonTypeView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('apiV1PersonGet', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('apiV1PersonGet', 'pageNumber', pageNumber)
            const localVarPath = `/api/v1/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Возвращает пользователя по id
         * @param {number} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonPersonIdGet: async (personId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('apiV1PersonPersonIdGet', 'personId', personId)
            const localVarPath = `/api/v1/person/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновляет данные пользователя
         * @param {number} personId 
         * @param {EditPerson} [editPerson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonPersonIdPut: async (personId: number, editPerson?: EditPerson, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('apiV1PersonPersonIdPut', 'personId', personId)
            const localVarPath = `/api/v1/person/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editPerson, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создает нового пользователя
         * @param {CreatePerson} [createPerson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonPost: async (createPerson?: CreatePerson, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPerson, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Возвращает текущего авторизованного пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonSelfGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/person/self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonApi - functional programming interface
 * @export
 */
export const PersonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Возвращает список пользователей
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {PersonTypeView} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonGet(pageSize: number, pageNumber: number, type?: PersonTypeView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPaginatedPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonGet(pageSize, pageNumber, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Возвращает пользователя по id
         * @param {number} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonPersonIdGet(personId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonPersonIdGet(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Обновляет данные пользователя
         * @param {number} personId 
         * @param {EditPerson} [editPerson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonPersonIdPut(personId: number, editPerson?: EditPerson, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonPersonIdPut(personId, editPerson, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Создает нового пользователя
         * @param {CreatePerson} [createPerson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonPost(createPerson?: CreatePerson, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonPost(createPerson, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Возвращает текущего авторизованного пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonSelfGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonSelfGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonApi - factory interface
 * @export
 */
export const PersonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonApiFp(configuration)
    return {
        /**
         * 
         * @summary Возвращает список пользователей
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {PersonTypeView} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonGet(pageSize: number, pageNumber: number, type?: PersonTypeView, options?: any): AxiosPromise<ResultPaginatedPerson> {
            return localVarFp.apiV1PersonGet(pageSize, pageNumber, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Возвращает пользователя по id
         * @param {number} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonPersonIdGet(personId: number, options?: any): AxiosPromise<ResultPerson> {
            return localVarFp.apiV1PersonPersonIdGet(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновляет данные пользователя
         * @param {number} personId 
         * @param {EditPerson} [editPerson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonPersonIdPut(personId: number, editPerson?: EditPerson, options?: any): AxiosPromise<ResultPerson> {
            return localVarFp.apiV1PersonPersonIdPut(personId, editPerson, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создает нового пользователя
         * @param {CreatePerson} [createPerson] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonPost(createPerson?: CreatePerson, options?: any): AxiosPromise<ResultPerson> {
            return localVarFp.apiV1PersonPost(createPerson, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Возвращает текущего авторизованного пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonSelfGet(options?: any): AxiosPromise<ResultPerson> {
            return localVarFp.apiV1PersonSelfGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonApi - object-oriented interface
 * @export
 * @class PersonApi
 * @extends {BaseAPI}
 */
export class PersonApi extends BaseAPI {
    /**
     * 
     * @summary Возвращает список пользователей
     * @param {number} pageSize 
     * @param {number} pageNumber 
     * @param {PersonTypeView} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public apiV1PersonGet(pageSize: number, pageNumber: number, type?: PersonTypeView, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).apiV1PersonGet(pageSize, pageNumber, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Возвращает пользователя по id
     * @param {number} personId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public apiV1PersonPersonIdGet(personId: number, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).apiV1PersonPersonIdGet(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновляет данные пользователя
     * @param {number} personId 
     * @param {EditPerson} [editPerson] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public apiV1PersonPersonIdPut(personId: number, editPerson?: EditPerson, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).apiV1PersonPersonIdPut(personId, editPerson, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создает нового пользователя
     * @param {CreatePerson} [createPerson] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public apiV1PersonPost(createPerson?: CreatePerson, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).apiV1PersonPost(createPerson, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Возвращает текущего авторизованного пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public apiV1PersonSelfGet(options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).apiV1PersonSelfGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoomApi - axios parameter creator
 * @export
 */
export const RoomApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Возвращает список помещений
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RoomGet: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('apiV1RoomGet', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('apiV1RoomGet', 'pageNumber', pageNumber)
            const localVarPath = `/api/v1/room`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создает новое помещение
         * @param {CreateRoom} [createRoom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RoomPost: async (createRoom?: CreateRoom, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/room`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoom, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновляет данные помещения
         * @param {number} roomId 
         * @param {EditRoom} [editRoom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RoomRoomIdPut: async (roomId: number, editRoom?: EditRoom, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('apiV1RoomRoomIdPut', 'roomId', roomId)
            const localVarPath = `/api/v1/room/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editRoom, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomApi - functional programming interface
 * @export
 */
export const RoomApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Возвращает список помещений
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RoomGet(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultPaginatedRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RoomGet(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Создает новое помещение
         * @param {CreateRoom} [createRoom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RoomPost(createRoom?: CreateRoom, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RoomPost(createRoom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Обновляет данные помещения
         * @param {number} roomId 
         * @param {EditRoom} [editRoom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RoomRoomIdPut(roomId: number, editRoom?: EditRoom, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RoomRoomIdPut(roomId, editRoom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoomApi - factory interface
 * @export
 */
export const RoomApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomApiFp(configuration)
    return {
        /**
         * 
         * @summary Возвращает список помещений
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RoomGet(pageSize: number, pageNumber: number, options?: any): AxiosPromise<ResultPaginatedRoom> {
            return localVarFp.apiV1RoomGet(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создает новое помещение
         * @param {CreateRoom} [createRoom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RoomPost(createRoom?: CreateRoom, options?: any): AxiosPromise<ResultRoom> {
            return localVarFp.apiV1RoomPost(createRoom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновляет данные помещения
         * @param {number} roomId 
         * @param {EditRoom} [editRoom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RoomRoomIdPut(roomId: number, editRoom?: EditRoom, options?: any): AxiosPromise<ResultRoom> {
            return localVarFp.apiV1RoomRoomIdPut(roomId, editRoom, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomApi - object-oriented interface
 * @export
 * @class RoomApi
 * @extends {BaseAPI}
 */
export class RoomApi extends BaseAPI {
    /**
     * 
     * @summary Возвращает список помещений
     * @param {number} pageSize 
     * @param {number} pageNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public apiV1RoomGet(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return RoomApiFp(this.configuration).apiV1RoomGet(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создает новое помещение
     * @param {CreateRoom} [createRoom] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public apiV1RoomPost(createRoom?: CreateRoom, options?: AxiosRequestConfig) {
        return RoomApiFp(this.configuration).apiV1RoomPost(createRoom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновляет данные помещения
     * @param {number} roomId 
     * @param {EditRoom} [editRoom] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public apiV1RoomRoomIdPut(roomId: number, editRoom?: EditRoom, options?: AxiosRequestConfig) {
        return RoomApiFp(this.configuration).apiV1RoomRoomIdPut(roomId, editRoom, options).then((request) => request(this.axios, this.basePath));
    }
}


